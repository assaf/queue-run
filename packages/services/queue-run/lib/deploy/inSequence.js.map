{"version":3,"sources":["/Users/assaf/Projects/queue.run/packages/services/lib/deploy/inSequence.ts"],"sourcesContent":["import ms from \"ms\";\nimport { AbortController, AbortSignal } from \"node-abort-controller\";\nimport {\n  cancelEarlierDeploys,\n  countActiveDeploys,\n  Deploy,\n  getDeploy,\n  getNextWaitingDeploy,\n  markDeployCompleted,\n  markDeployStarted,\n} from \"./state\";\nimport { readS3Archive } from \"./storage\";\n\ntype RunDeployHandler = ({\n  // Zip with code to deploy\n  archive,\n  deploy,\n  // Deploy cancelled by user or timed out\n  signal,\n}: {\n  archive: Buffer;\n  deploy: Deploy;\n  signal: AbortSignal;\n}) => Promise<void>;\n\n// We use this to deploy in sequence.\n//\n// We want to avoid a race condition: when user starts two deploys on the same\n// branch, they must run in order.\n//\n// While the first deploy is running, it blocks the second deploy. We can also\n// use this strategy to limit to N deploys across a project, team, etc.\n//\n// We can't block the job, so if we determine another deploy is running, we end\n// the job early. And so, whenever a deploy finishes, it needs to look for any\n// other waiting deploy, and queue a job to run it.\n//\n// We use the database to track the state of each deploy. We don't have locks,\n// but we can avoid a race condition by using a FIFO queue. That guarantees all\n// jobs for the same project/branch run in sequence.\n//\n// A queued job will either:\n// - Determine it's blocked by another deploy and finish early\n// - Determine another job failed to complete this deploy, queue the next deploy, finish early\n// - Run this deploy until it completes or times out\n//\nexport async function deployInSequence(\n  {\n    deployId,\n    signal,\n  }: {\n    deployId: string;\n    signal: AbortSignal;\n  },\n  runDeploy: RunDeployHandler\n) {\n  console.info(\"Starting deploy %s\", deployId);\n\n  const deploy = await getDeploy(deployId);\n  if (!deploy) return console.error(\"Deploy %s not found, bailing\", deployId);\n\n  // FIFO guarantees that deploy jobs run in order, and we don't have duplicates\n  // in the queue. The same deploy can run in parallel, if the previous run\n  // crashed or timed out.\n  if (deploy.startedAt) {\n    console.info(\n      \"Deploy %s not finished in time, marking as failed, and scheduling next deploy\",\n      deployId\n    );\n    if (!deploy.completedAt) await markDeployCompleted(deployId, \"failed\");\n    // If there's doubt, we call queueNextDeploy\n    return queueNextDeploy(deploy);\n  }\n\n  // If there are other deploys waiting to run cancel them, we only want the\n  // most recent deploy\n  await cancelEarlierDeploys(deploy);\n\n  // We only allow user to have one running deploy at a time\n  if ((await countActiveDeploys(deploy.projectId)) > 0) {\n    console.info(\"Deploy %s blocked, another deploy is in progress\", deployId);\n    return;\n  }\n\n  await markDeployStarted(deployId);\n  try {\n    await watchDeployStatus({ deployId, signal }, async (signal) => {\n      const archive = await readS3Archive(deployId);\n      await runDeploy({ archive, deploy, signal });\n\n      if (signal.aborted) return;\n      await markDeployCompleted(deployId, \"success\");\n      console.info(\"Deploy %s completed successfully\", deployId);\n    });\n  } catch (error) {\n    console.error(\"Deploy %s failed\", deployId, error);\n    await markDeployCompleted(deployId, \"failed\");\n  }\n  return await queueNextDeploy(deploy);\n}\n\nasync function watchDeployStatus(\n  { deployId, signal: timeout }: { deployId: string; signal: AbortSignal },\n  cb: (signal: AbortSignal) => Promise<void>\n) {\n  const cancel = new AbortController();\n  timeout.addEventListener(\"abort\", () => cancel.abort());\n\n  setInterval(async function pollDeployStatus() {\n    const deploy = await getDeploy(deployId);\n    if (!deploy || deploy.completedAt) cancel.abort();\n  }, ms(\"5s\"));\n\n  try {\n    await Promise.race([\n      cb(cancel.signal),\n      new Promise((resolve) =>\n        cancel.signal.addEventListener(\"abort\", resolve)\n      ),\n    ]);\n    if (timeout.aborted) throw new Error(\"Deploy timed out\");\n    if (cancel.signal.aborted) throw new Error(\"Deploy cancelled by user\");\n  } finally {\n    cancel.abort();\n  }\n}\n\n// When we're done with this deploy, queue the next waiting deploy\nasync function queueNextDeploy(deploy: Deploy) {\n  const nextDeployId = await getNextWaitingDeploy(deploy);\n  if (nextDeployId) {\n    // TODO queue with { deployId } groupId = project/branch\n  }\n}\n"],"names":["deployInSequence","deployId","signal","runDeploy","console","info","deploy","error","startedAt","completedAt","queueNextDeploy","projectId","watchDeployStatus","archive","aborted","timeout","cb","cancel","addEventListener","abort","setInterval","pollDeployStatus","Promise","race","resolve","Error","nextDeployId"],"mappings":"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"}